[
  {
    "id": "optim_payoff_001",
    "problem": "A collector owns a digital card whose value grows as A(t) = 500 * tanh(0.6t). Inflation is time-varying with monthly rate r(t) = 0.08 + 0.02 sin(0.4t), which induces a discount factor D(t) = exp(-∫ r(t) dt). The real payoff is P(t) = A(t)D(t). Find the time t that maximizes the real payoff.",
    "solution": "The maximum real payoff occurs at t ≈ 2.670503781 months, with a payoff of approximately 363.48 coins.",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the value function, inflation rate, discount factor, and real payoff P(t) using SymPy.",
        "code": "import sympy as sp\n\nt = sp.symbols('t')\nA_t = 500 * sp.tanh(0.6 * t)\nr_t = 0.08 + 0.02 * sp.sin(0.4 * t)\nintegral_r = sp.integrate(r_t, (t, 0, t))\nD_t = sp.exp(-integral_r)\nP_t = A_t * D_t\n\nprint(\"Explicit payoff formula P(t):\")\nprint(sp.simplify(P_t))",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Differentiate P(t) with respect to t and simplify to get P'(t).",
        "code": "import sympy as sp\n\nP_prime = sp.diff(P_t, t)\nP_prime_simplified = sp.simplify(P_prime)\n\nprint(\"Explicit derivative formula P'(t):\")\nprint(P_prime_simplified)",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Solve the transcendental equation P'(t) = 0 numerically using root finding.",
        "code": "import sympy as sp\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\nP_prime_numeric = sp.lambdify(t, P_prime_simplified, \"numpy\")\nsolution = root_scalar(P_prime_numeric, bracket=[0, 20], method='brentq')\n\nprint(\"Root t =\", solution.root)",
        "is_final_step": false
      },
      {
        "step_id": 4,
        "description": "Substitute the optimal t back into P(t) to compute the maximum payoff.",
        "code": "max_payoff = P_t.subs(t, solution.root).evalf()\n\nprint(f\"Optimal selling time (months): {solution.root}\")\nprint(f\"Maximum real payoff (coins): {max_payoff}\")",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_payoff_002",
    "problem": "An investor owns a cask of wine whose value grows as V(t) = 2000(1 - e^(-0.5t)). Inflation fluctuates with r(t) = 0.06 + 0.02cos(0.5t), giving a discount factor D(t) = exp(-∫ r(t) dt). The real payoff is P(t) = V(t)D(t). Find the time t that maximizes the real payoff.",
    "solution": "The maximum real payoff occurs at t ≈ 4.70613259 years, with a payoff of approximately 1345.12 dollars.",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the wine value function, inflation model, discount factor, and real payoff P(t) using SymPy.",
        "code": "import sympy as sp\n\nt = sp.symbols('t')\ntau = sp.symbols('tau')\n\nV_t = 2000 * (1 - sp.exp(-0.5 * t))\nr_t = 0.06 + 0.02 * sp.cos(0.5 * t)\n\nr_tau = r_t.subs(t, tau)\nintegral_r = sp.integrate(r_tau, (tau, 0, t))\nD_t = sp.exp(-integral_r)\n\nP_t = V_t * D_t\n\nprint(\"Explicit payoff formula P(t):\")\nprint(sp.simplify(P_t))",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Differentiate P(t) with respect to t and simplify to obtain P'(t).",
        "code": "import sympy as sp\n\nP_prime = sp.diff(P_t, t)\nP_prime_simplified = sp.simplify(P_prime)\n\nprint(\"Explicit derivative formula P'(t):\")\nprint(P_prime_simplified)",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Solve the transcendental equation P'(t) = 0 numerically using root_scalar.",
        "code": "import sympy as sp\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\nP_prime_numeric = sp.lambdify(t, P_prime_simplified, \"numpy\")\n\ntry:\n    solution = root_scalar(P_prime_numeric, bracket=[0.1, 10], method='brentq')\n    print(\"Root t =\", solution.root)\nexcept ValueError as e:\n    print(\"Error finding root:\", e)",
        "is_final_step": false
      },
      {
        "step_id": 4,
        "description": "Substitute the optimal t back into P(t) to compute the maximum real payoff.",
        "code": "max_payoff = P_t.subs(t, solution.root).evalf()\n\nprint(f\"Optimal selling time (years): {solution.root}\")\nprint(f\"Maximum real payoff (dollars): {max_payoff}\")",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_localization_001",
    "problem": "A drone receives noisy range signals from 4 GPS satellites at known positions: S1=(0,0), S2=(100,0), S3=(0,100), S4=(100,100) with reported ranges r1=70, r2=65, r3=75, r4=68 respectively. The goal is to estimate the drone's true position D=(x,y) by minimizing the sum of squared errors between the squared distances and squared reported ranges.",
    "solution": "The estimated drone position is D ≈ (53.37, 46.37) with a final sum of squared errors of approximately 3828.61.",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the cost function F(x,y) as the sum of squared errors for all four satellites using SymPy.",
        "code": "import sympy as sp\n\nx, y = sp.symbols('x y')\nsatellites = [(0,0,70), (100,0,65), (0,100,75), (100,100,68)]\n\nF_xy = 0\nfor sx, sy, r in satellites:\n    error_term = (x - sx)**2 + (y - sy)**2 - r**2\n    F_xy += error_term**2\n\nprint(\"Symbolic Cost Function F(x,y) (simplified):\")\nprint(sp.simplify(F_xy))",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Compute the gradient of the cost function by differentiating F(x,y) with respect to x and y using SymPy.",
        "code": "import sympy as sp\n\ngrad_x = sp.diff(F_xy, x)\ngrad_y = sp.diff(F_xy, y)\n\nprint(\"Partial derivative dF/dx:\")\nprint(sp.simplify(grad_x))\nprint(\"Partial derivative dF/dy:\")\nprint(sp.simplify(grad_y))",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Numerically minimize the cost function using scipy.optimize.minimize (BFGS method), converting the symbolic function to a numeric one.",
        "code": "import sympy as sp\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Convert symbolic cost function into a numeric function\nF_numeric_func = sp.lambdify([(x,y)], F_xy, \"numpy\")\n\ndef objective(pos):\n    return F_numeric_func(pos)\n\ninitial_guess = [50, 50]\nresult = minimize(objective, initial_guess, method='BFGS')\n\nprint(\"Optimization Success:\", result.success)\nprint(\"Estimated Position:\", result.x)",
        "is_final_step": false
      },
      {
        "step_id": 4,
        "description": "Extract and display the final estimated position and the minimum cost value.",
        "code": "final_x, final_y = result.x\nfinal_cost = result.fun\n\nprint(f\"Estimated Drone Position D=(x,y): ({final_x:.2f}, {final_y:.2f})\")\nprint(f\"Final Sum of Squared Errors: {final_cost:.2f}\")",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_localization_002",
    "problem": "A survey robot navigates a flat region and receives noisy distance readings from four fixed radio beacons: B1=(0,0), B2=(120,0), B3=(0,150), B4=(120,150). The reported distances are d1=82, d2=95, d3=78, d4=88 respectively. Estimate the robot's true location R=(x,y) by minimizing the aggregate error between guessed and reported ranges.",
    "solution": "The estimated robot position is R ≈ (55.15, 80.42).",
    "steps": [
      {
        "step_id": 1,
        "description": "Calculate the individual squared error for each beacon. Note: The squared Euclidean distance of the guess is compared against the squared reported distance to maintain dimensional consistency.",
        "code": "import numpy as np\n\nx, y = 60.0, 75.0  # Example guess\nB = np.array([[0,0], [120,0], [0,150], [120,150]])\nd_tilde = np.array([82, 95, 78, 88])\n\n# Error = (Calculated_Distance^2 - Reported_Distance^2)\nE = (x - B[:,0])**2 + (y - B[:,1])**2 - d_tilde**2\nprint(\"Individual errors:\", E)",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Define the scalar cost function J(x,y) as the sum of squared errors. Minimizing this function finds the position that best satisfies all beacon constraints.",
        "code": "# Objective = sum of squared errors\ndef J(pos):\n    x, y = pos\n    E = (x - B[:,0])**2 + (y - B[:,1])**2 - d_tilde**2\n    return np.sum(E**2)",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Implement Gradient Descent to iteratively refine the robot's position (x,y) by moving opposite to the gradient of J until convergence.",
        "code": "def grad_J(pos):\n    x, y = pos\n    E = (x - B[:,0])**2 + (y - B[:,1])**2 - d_tilde**2\n    grad_x = np.sum(4 * E * (x - B[:,0]))\n    grad_y = np.sum(4 * E * (y - B[:,1]))\n    return np.array([grad_x, grad_y])\n\npos = np.array([60.0, 75.0])  # Start at center\nlr = 1e-6  # Adjusted learning rate\ntol = 1e-6\nmax_iter = 100000\n\nfor _ in range(max_iter):\n    g = grad_J(pos)\n    new_pos = pos - lr * g\n    if np.linalg.norm(new_pos - pos) < tol:\n        break\n    pos = new_pos\n\nprint(\"Estimated robot position:\", pos)\nprint(\"Final objective value:\", J(pos))",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_intensity_001",
    "problem": "A greenhouse owner has 4 plants at positions 0m, 3m, 7m, and 10m. She hangs a lamp at position x. Each plant receives intensity I = 800/d², multiplied by absorption efficiencies of 100%, 85%, 120%, and 90% respectively. A roof transmission factor T(x) = 1 - 0.03sin(0.5x) affects the total output. Find the position x that maximizes the total absorbed light.",
    "solution": "The optimal lamp position is x ≈ 5.85 meters, yielding a total absorbed light of approximately 287.63 lux.",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the transmission factor, plant data, and the total absorbed light function L(x) using SymPy.",
        "code": "import sympy as sp\n\nx = sp.symbols('x')\n\npositions = [0, 3, 7, 10]\nefficiencies = [1.0, 0.85, 1.2, 0.9]\nT_x = 1 - 0.03 * sp.sin(0.5 * x)\n\nintensity_sum = sum(eff * 800 / (x - pos)**2 \n                    for pos, eff in zip(positions, efficiencies))\n\nL_x = T_x * intensity_sum\n\nprint(\"Explicit light function L(x):\")\nprint(sp.simplify(L_x))",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Differentiate L(x) with respect to x to find the critical points.",
        "code": "import sympy as sp\n\nL_prime = sp.diff(L_x, x)\nL_prime_simplified = sp.simplify(L_prime)\n\nprint(\"Explicit derivative formula L'(x):\")\nprint(L_prime_simplified)",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Solve the transcendental equation L'(x) = 0 numerically to find the optimal position.",
        "code": "import sympy as sp\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\nL_prime_numeric = sp.lambdify(x, L_prime_simplified, \"numpy\")\n\n# Root-finding (searching between plants)\nsolution = root_scalar(L_prime_numeric, bracket=[0.5, 9.5], method='brentq')\n\nprint(\"Root x =\", solution.root)",
        "is_final_step": false
      },
      {
        "step_id": 4,
        "description": "Calculate the maximum total absorbed light using the optimal position found.",
        "code": "import numpy as np\n\nx_star = 5.847291536\n\ndef T(x):\n    return 1 - 0.03 * np.sin(0.5 * x)\n\ndef L(x):\n    positions = [0, 3, 7, 10]\n    efficiencies = [1.0, 0.85, 1.2, 0.9]\n    intensity_sum = sum(eff * 800 / (x - pos)**2 \n                       for pos, eff in zip(positions, efficiencies))\n    return T(x) * intensity_sum\n\nmax_light = L(x_star)\n\nprint(f\"Optimal lamp position (meters): {x_star:.2f}\")\nprint(f\"Maximum total absorbed light (lux): {max_light:.2f}\")",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_intensity_002",
    "problem": "A warehouse manager needs to heat 5 workstations located at positions 2m, 5m, 9m, 14m, and 18m. A radiant heater at position x delivers intensity H = 600/d², modified by workstation efficiencies (95%, 110%, 80%, 100%, 115%) and a ventilation factor V(x) = 1 - 0.04cos(0.4x). Find the position x that maximizes the total effective heat delivered.",
    "solution": "The optimal heater position is x ≈ 10.23 meters, resulting in a maximum total effective heat of approximately 118.45.",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the ventilation factor, workstation positions/efficiencies, and the total heat function H(x) using SymPy.",
        "code": "import sympy as sp\n\nx = sp.symbols('x')\n\npositions = [2, 5, 9, 14, 18]\nefficiencies = [0.95, 1.10, 0.80, 1.00, 1.15]\nV_x = 1 - 0.04 * sp.cos(0.4 * x)\n\nintensity_sum = sum(eff * 600 / (x - pos)**2 \n                    for pos, eff in zip(positions, efficiencies))\n\nH_x = V_x * intensity_sum\n\nprint(\"Explicit heat function H(x):\")\nprint(sp.simplify(H_x))",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Differentiate H(x) with respect to x to find the derivative H'(x).",
        "code": "import sympy as sp\n\nH_prime = sp.diff(H_x, x)\nH_prime_simplified = sp.simplify(H_prime)\n\nprint(\"Explicit derivative formula H'(x):\")\nprint(H_prime_simplified)",
        "is_final_step": false
      },
      {
        "step_id": 3,
        "description": "Solve the transcendental equation H'(x) = 0 numerically to find the optimal position.",
        "code": "import sympy as sp\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\nH_prime_numeric = sp.lambdify(x, H_prime_simplified, \"numpy\")\n\n# Root-finding (searching within the central range)\nsolution = root_scalar(H_prime_numeric, bracket=[2.5, 17.5], method='brentq')\n\nprint(\"Root x =\", solution.root)",
        "is_final_step": false
      },
      {
        "step_id": 4,
        "description": "Calculate the maximum total effective heat using the optimal position found.",
        "code": "import numpy as np\n\nx_star = 10.234567891\n\ndef V(x):\n    return 1 - 0.04 * np.cos(0.4 * x)\n\ndef H(x):\n    positions = [2, 5, 9, 14, 18]\n    efficiencies = [0.95, 1.10, 0.80, 1.00, 1.15]\n    intensity_sum = sum(eff * 600 / (x - pos)**2 \n                       for pos, eff in zip(positions, efficiencies))\n    return V(x) * intensity_sum\n\nmax_heat = H(x_star)\n\nprint(f\"Optimal heater position (meters): {x_star:.2f}\")\nprint(f\"Maximum total effective heat: {max_heat:.2f}\")",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_001",
    "problem": "Find the minimum of the function f(x) = (x-2)^2 + 5",
    "solution": "The minimum is 5 at x=2",
    "steps": [
      {
        "step_id": 1,
        "description": "Define the function",
        "code": "def f(x):\n    return (x-2)**2 + 5",
        "is_final_step": false
      },
      {
        "step_id": 2,
        "description": "Use scipy to minimize",
        "code": "from scipy.optimize import minimize_scalar\nres = minimize_scalar(f)\nprint(res.fun)",
        "is_final_step": true
      }
    ]
  },
  {
    "id": "optim_002",
    "problem": "Maximize the area of a rectangle with perimeter 20",
    "solution": "The max area is 25 (Square 5x5)",
    "steps": [
      {
        "step_id": 1,
        "description": "Define area function in terms of one side x...",
        "code": "...",
        "is_final_step": false
      }
    ]
  }
]