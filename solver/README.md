# Optimization Solver AI

A highly capable AI-powered mathematical optimization and code-solving platform. This application seamlessly integrates a modern React frontend with a scalable Python backend, offering state-of-the-art context-aware prompt execution using Large Language Models (LLMs) and containerized Python kernels.

## Overview

The Optimization Solver AI is designed to assist professionals, researchers, and students in formulating and solving complex mathematical models. By converting conversational prompts into executable Python code, it solves models systematically using solvers like Pyomo, Gurobi, GLPK, and XGBoost. The execution context is isolated and persistently maintained across multi-step reasoning processes.

## Features

- **Conversational Problem Solving:** Input optimization problems in natural language, and the AI models, executes, and returns results.
- **Stateful Python Kernel Execution:** Continuous session affinity across prompts using a custom Jupyter kernel manager.
- **Robust Optimization Focus:** Handles Linear, Mixed-Integer, Non-Linear, and specific structured data analysis paradigms.
- **RAG-based Context Retrieval:** Uses Pinecone Vector DB to draw parallels from prior established formulations to minimize hallucination.
- **Data Integrations:** Securely upload large CSV and Excel datasets directly to Google Cloud Storage (GCS) for processing.
- **Modern UI:** Responsive split-layout frontend with React LaTeX parsing and interactive step blocks.

## System Architecture

The project consists of a React frontend and two primary backend services:

1.  **Frontend (React / Vite):**
    -   Handles user queries, authentication (via Clerk), file uploads, and Server-Sent Events (SSE) streaming of LLM steps.
    -   Responsive split-pane UI.
2.  **API Backend (FastAPI):**
    -   Manages chat history via Firebase Realtime Database.
    -   Interfaces with Google Gemini LLMs and Pinecone vector database.
    -   Streams step-by-step reasoning and orchestrates tasks.
3.  **Kernel Executor (FastAPI):**
    -   Stateful environment executing unstructured Python code generated by the LLM.
    -   Persistent Jupyter Kernel architecture prevents state wipe between prompt queries.
    -   Integrates strictly with Google Cloud Storage for upload reading and result exporting.

## Tech Stack

*   **Frontend:** React, Vite, Clerk (Auth), KaTeX (Math rendering)
*   **Backend:** FastAPI, Python, Jupyter Client, httpx, Firebase Admin SDK
*   **AI / ML:** Google Gemini APIs, Pinecone Vector Database
*   **Infrastructure:** Docker, Google Cloud Run, Google Cloud Storage

## Getting Started

### Prerequisites

-   Docker & Docker Compose
-   Node.js 18+
-   Python 3.10+
-   Google Cloud Service Account credentials (for GCS/Logging)
-   Gemini API Key
-   Pinecone API Key
-   Firebase API keys and project settings

### Environment Variables

You need to provide the appropriate `.env` file in the project's root directory:

```env
GOOGLE_API_KEY=your_gemini_api_key
PINECONE_API_KEY=your_pinecone_api_key
GCS_BUCKET_NAME=your_gcs_bucket_name

# Firebase Credentials
FIREBASE_TYPE=service_account
FIREBASE_PROJECT_ID=...
FIREBASE_PRIVATE_KEY_ID=...
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
FIREBASE_CLIENT_EMAIL=...
FIREBASE_CLIENT_ID=...
FIREBASE_AUTH_URI=...
FIREBASE_TOKEN_URI=...
FIREBASE_AUTH_PROVIDER_X509_CERT_URL=...
FIREBASE_CLIENT_X509_CERT_URL=...
FIREBASE_UNIVERSE_DOMAIN=...
FIREBASE_DB_URL=...
```

### Running Locally

To spin up the local environment, including both the executor and backend, run:

```bash
docker-compose up --build
```

Then, natively start the Vite frontend:

```bash
npm install
npm run dev
```

## Security & Confinement

*   **Safe Code Execution:** The code executor imposes stringent timeouts on long-running problems and forces explicit timeout logic inside algorithmic solver calls (`TimeLimit=30`).
*   **Storage Quotas:** Sessions are bound to a strict storage limit (e.g., 1.5GB) to prevent denial of service by large dataset explosion.
*   **Data Ephemerality:** A janitor process routinely sweeps abandoned sandbox sessions from both disk and bucket logic.
